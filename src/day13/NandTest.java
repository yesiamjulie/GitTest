package day13;

import java.util.Random;

public class NandTest {
    public static void main(String[] args) {

        /*
            16진수 표기법:
            1. 맨 앞에 0x를 붙인다.
            2. 0~9까지는 동일하다.
            3. a- 10, b- 11, c- 12, d- 13, e -14, f -15
            4. 10진수는 0~9까지 , 16진수는 0~f(15)까지
            5. 16진수 1자리는 2진수 4자리로 대체된다.
               (2^4 = 16 이라서 그렇다.)
         */
        int positive = 0xffffffff;
        int positive2 = 0xf; // 1111(2) , 15

        /*
            16진수 => 2 진수와 2진수 -> 16진수를 잘 바꿀 수 있어야 한다.

            0xf -> 10진수 15 -> 1111(2)
                    15 -8 -> 2^3
                    7-4 -> 2^2
                    3-2 -> 2^1
                    1   -> 2^0
                    0xf = 1111(2)
            0xc -> 10진수 12 -> 1100(2)

            ** 16진수 변환의 장점( 빠르게 비트 수를 볼 수 있다 )**

            0xcf38ad --> 2진수 변환
            c : 1100
            f : 1111
            3 : 0011
            8 : 1000
            a : 1010
            d : 1101

            0xca --> 2진수 변환
            1100 1010

            12(c) * 16^ 1 + 10(a) * 16 ^0 = 202 ( 16진수로 계산)
            2^7 + 2^6 + 2^3 + 2^1 = 202  (2진수로 계산)


            +1 bytes = 8bit
         */

        int notPos = ~positive;
        System.out.println("notPos = " + notPos);

        int notPos2 = ~positive2;
        System.out.println("notPos = " + notPos2);

        /*
            [음수를 bit로 해석하는 방법] ( 정석은 2의 보수를 만드는 방법 ) - 꼼수
            1. 첫 번째 1을 찾는다.
            2. 첫 번째 1을 포함하여 이전 정보를 유지한다.
            3. 나머지는 전부 반전한다.
            4. 그 결과를 재해석하면, 음수가 된다.

            결론 : 양수를 음수로 바꾼 기법임 / 음수를 양수로 바꿀 수도 있음


        */
        /*
            Q. -15를 bit로 표현해보자~
            -15 = -X로 놓고 음수 양수 변환 꼼수를 쓴다.
            15 = X가 될 것이므로
                            00001111(2) = 15
            꼼수를 적용하면   11110001(1) =-15

            Q . ~112를 bit로 표기하고 구해보자
            112는 64 + 32 + 16 이므로
                             01110000
            ~(not)을 적용하면 10001111
            위와 마찬가지로 이 녀석이 얼마인지를 모르니
            동일하게 -X로 놓고 꼼수를 적용한다.
            그러면 결과는     01110001이 되므로
            64 + 32 + 16 + 1 = 113이 되고
            ~112는 결국 -113이 된다.
         */
        System.out.println("positive" + positive);

        /*
            실제 이 bit가 어떤 음수인가?
            1. 우리가 찾으려는 임의의 음수를 x로 지정한다.
            2. 여기에 위의 음수를 bit로 해석하는 기법을 적용한다.
            3. 그럼 결과만 양수로 나올 것이다.

            예 ) 11110001 = -X
                 00001111 = 15
                 x값은 15라는 결과를 얻을 수 있다.
         */
        System.out.println("~00001110(2) == ~14 ==" + (~14));

        int[] arr;
        arr = new int[16];
        Random rand = new Random();

        // nand를 쓰는 경우 반드시 2^n -1의 숫자를 배치하도록 한다.

        for (int i = 0; i < 16; i++) {

            arr[i] = rand.nextInt(128) + 1; // 1~128 사이의 난수값을 지정합니다.
            System.out.println("arr[" + i + "]=" + arr[i] + ", arr[" + i + "] &~ 15=" + (arr[i] &~ 15));
            /*  &~7의 결과는 모두 8의 배수로 산출된다. 또, &~ 15의 결과는 모두 16의 배수로 출력된다.
                구간의 gap을 특정한 숫자 단위로 한정지을 수 있다. ( 창고관리 프로그램 : 재고관리)
            *   효율성을 중시하는 데에서는 &~이 자주 사용된다.*/

            /*
                not은 모든 비트를 반전

             */

            /*
                  문제 5.
                  ~77 을 bit(2진수)로 표현하고 해석하시오.

                  77 - 2^6 = 64  -> 13

                  13 - 2^3 = 8   -> 5

                  5 - 2^2 = 4    -> 1

                  2^0

                   77 = 0100 1101(2)

                   ~77= 1011 0010(2) -X
                        0100 1110(2) +X
                        64 + 8 + 4 + 2 = 78 = X
                   그러므로 -X = -78
             */



            /*
                숙제 7 -1.  -137을 bit로 표현하시오.

                2^7 = 128

               9
               2^3 = 8

               1 =2^0

               +137= 1000 1001

                     0111 0110 ( 2의 보수 _)
                             1
                     0111 1001
                     1000 1010


                숙제 7- 2.  10001010 11111010을 10진수로 표현하시오.

                숙제 7- 3.  랜덤 숫자를 입력받아서
                           1024 단위로 정렬하도록 프로그래밍 하시오.

             */
        }
    }

}
