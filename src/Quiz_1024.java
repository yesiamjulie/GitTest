public class Quiz_1024 {
    public static void main(String[] args) {
        /*
        (삼성무선사업부 면접 문제)

        1,      5 ,    10,  10,  15,    150, 1500, 2300,
        2350,   2350,   2350,    2350,  2350,  2350, 2350, 2350,
        23423,  1231,   52352, 2352332, 13123, 34531, 2342,
        1231, 2342, 2342, 368, 4675, 47905 , 45604, 4500,
        5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000

        위와 같은 데이터가 배열에 들어있다고 가정한다(무선 주파수임)
        여기서 가장 빈도수가 높은 주파수 대역을 2개 추출하고
        몇 번 검출되었는지 확인하는 프로그램을 작성하시오.

        1. 목적 : 가장 빈번한 숫자 2개와 출현 횟수
        2. 배열을 활용화도록 한다.
        3. 각각이 몇 번 출현했는지(빈도수)를 표현해주는 배열이 필요하다.
        4. 이것에 대응되는 숫자 배열이 필요하다.
           (빈도수가 어떤 숫자인지를 알 필요가 있기 때문)
        5. 숫자 값들이 오름차순으로 정렬되면 좀 더 편할 것이다.


     */

        int[] wirelessFreq = {
                1, 5, 10, 10, 15, 150, 1500, 2300,
                2350, 2350, 2350, 2350, 2350, 2350, 2350, 2350,
                23423, 1231, 52352, 2352332, 13123, 34531, 2342,
                1231, 2342, 2342, 368, 4675, 47905, 45604, 4500,
                5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000

        };

        int i, j, key;


        //배열의 원소 개수를 파악하는 데 사용함.
        int len = wirelessFreq.length;


        /*
        1) 오름차순 정렬부터!
           정렬알고리즘 ( Insertion Sort)

        ### 동작과정 분석 ###
            23423 , 1231, 52352, 2352332
            [0]     [1]     [2]     [3]

        key= 1231 , i = 1
        j  = 0, 23423 > 1231
        j  = 1, 23423

        j = 0 = 1231

        1231 23423 52352  2342332


         */

        int[] number; // 숫자배열
        int[] freqCheck; // 빈도수 배열

        /*
            ### 추가 사항 ###
            프로그램 개발을 하다보면, 최초 설계와는 다르게
            구현상 문제들이 발생하는 경우가 있습니다.
            이런 경우에 해당 문제를 어떻게 해결할 것인지 짱구를 굴립니다~

            숫자배열과 빈도수 배열을 작성하는데 문제 발생 **
            어떤 문제가 있을까?
            - 중복되는 숫자가 몇 개 있는지 모르기 때문에,
              정확한 원소의 개수를 산출 할 수 없다.

              **그러므로 먼저 중복되지 않은 원소 개수를 판별 할 필요가 있다.
              앞 요소들과 비교해 같지 않으면 카운트 ++


         */
        int nonRecursNum = 0;


        for (i = 0; i < len; i++) {
            if (i == 0) {
                nonRecursNum++; // 첫번째는 무조건 ++ , 처음부터 중복되는 일은 없으니까!
                continue; // continue는 무조건 다시 for문으로 돌아가게 한다. 단, 증감부를 거치게 됨.
            }

            //중복이 없으면
            for (j = 0; j < i; j++) { // i번째 전까지만 볼꺼니까 j<i
                if (wirelessFreq[i] == wirelessFreq[j]) {
                    //중복이 있다면 for문을 바로 빠져나옴
                    //그러므로 j값이 어떤 경우에도 i와 같아질 수 없다.

                        break;
                }


            }

            if (j == i) {
                nonRecursNum++;
            }

        }

        for (i = 1; i < len; i++) {
            key = wirelessFreq[i];


            for (j = i - 1; wirelessFreq[j] > key; j--) {
                wirelessFreq[j + 1] = wirelessFreq[j];
            }
            wirelessFreq[j + 1] = key;
        }

        for (i = 0; i < len; i++) {
            System.out.println("arr[" + i + "] = " + wirelessFreq[i]);

        }

        System.out.println("중복 없는 원소의 개수 : " + nonRecursNum);

    }


        /*

        int[] array = new int[50];
        int[] res = new int[20];
        int freq=0;


        Scanner in = new Scanner(System.in);

        for (int i = 0; i < 50; i++) {
            System.out.println("주파수 값을 순서대로 입력하세요 : ");
            array[i] = in.nextInt();
        }

        for (int i = 0; i < 50; i++) {

            System.out.println(array[i]);

            for (int j = 0; j < 50; j++) {
                if (array[i] == array[j]){

                    res[j] = array[j];


                }
            }

        }

    }

         */
}
